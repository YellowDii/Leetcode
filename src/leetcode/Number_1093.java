package leetcode;

/**
 * 1093.大样本统计
 * 我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 的采样个数。
 *
 * 我们以 浮点数 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。
 *
 * 我们先来回顾一下中位数的知识：
 *
 * 如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；
 * 如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。
 *  
 *
 * 示例 1：
 *
 * 输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
 * 输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
 * 示例 2：
 *
 * 输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
 * 输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
 *  
 *
 * 提示：
 *
 * count.length == 256
 * 1 <= sum(count) <= 10^9
 * 计数表示的众数是唯一的
 * 答案与真实值误差在 10^-5 以内就会被视为正确答案
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/statistics-from-a-large-sample
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class Number_1093 {
    //注意sum应该用double类型，用int类型会出错，可能是溢出
    //而nums=sum(count)<10^9，不会超出int上限
    public double[] sampleStats(int[] count) {
        double[] res=new double[5];
        //最小值
        for (int i=0;i<256;i++){
            if (count[i]!=0){
                res[0]=(double)i;
                break;
            }
        }
        //最大值
        for (int i=255;i>0;i--){
            if (count[i]!=0){
                res[1]=(double)i;
                break;
            }
        }
        //平均数
        double sum=0;int nums=0;
        for (int i=0;i<256;i++){
            if (count[i]!=0){
                nums+=count[i];
                sum+=count[i]*i;
            }
        }
        res[2]=sum/nums;
        //中位数
        //分偶数情况与奇数情况
        if (nums%2==0){
            int pos1=nums/2,pos2=pos1+1,cur=0;
            for (int i=0;i<256;i++){
                cur+=count[i];
                //两数相等时
                if (cur>pos1&&cur>=pos2){
                    res[3]=(double)i;
                    break;
                }
                //前面这个数刚好处在边界时
                if(cur==pos1){
                    res[3]=(double)i;
                    //记录前中位数位置
                    cur=i;
                    break;
                }
            }
            for(int i=cur+1;i<256;i++){
                if (count[i]!=0){
                    res[3]=(res[3]+(double)i)/2;
                    break;
                }
            }
        }else {
            int pos=nums/2+1,cur=0;
            for (int i=0;i<256;i++){
                cur+=count[i];
                if (cur>=pos){
                    res[3]=(double)i;
                    break;
                }
            }
        }
        //众数
        int max=0;
        for (int i=0;i<256;i++){
            if (max<count[i]){
                res[4]=(double)i;
                max=count[i];
            }
        }
        return res;
    }
}
