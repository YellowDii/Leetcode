package leetcode;

import java.util.Arrays;

/**
 * 1040. 移动石子直到连续 II
 * 在一个长度无限的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作端点石子。
 *
 * 每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。
 *
 * 值得注意的是，如果石子像 stones = [1,2,5] 这样，你将无法移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），
 *
 * 该石子都仍然会是端点石子。
 *
 * 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。
 *
 * 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。
 *
 *  
 *
 * 示例 1：
 *
 * 输入：[7,4,9]
 * 输出：[1,2]
 * 解释：
 * 我们可以移动一次，4 -> 8，游戏结束。
 * 或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。
 * 示例 2：
 *
 * 输入：[6,5,4,3,10]
 * 输出：[2,3]
 * 解释：
 * 我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。
 * 或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。
 * 注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。
 * 示例 3：
 *
 * 输入：[100,101,104,102,103]
 * 输出：[0,0]
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/moving-stones-until-consecutive-ii
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class Number_1040 {
    //该题解答思路比较难思考，这里参考了置顶的精选解答
    //从题意来看，就是要把两边的石子往中间放，每一次只能动最左边或最右边的石子
    //1.如何求最大值呢，这里我们可以把整个过程分为两步，第一步就是选取最左边或最右边的石子放置在中间
    //后面只需要按照策略（端点石子每次向离自己最近的空格移动），一步步的填充中间的空格。
    // 总步数就是：中间的空格数-第一步空格数减少量，前者为定值：stones[N-1]-stones[0]+1-N
    //要是总步数最长，就要使后者最小，表达式为：min(stones[1)-stones[0]-1,stones[N-1]-stones[N-2]-1)
    //比如说下面这个例子：6 _ _ 9 10 _ _ 13  _ 15
    //(1).15->12 后面按照策略
    // (2).13->11 (3).12->8 (4).11->7  max=5-min(1,2)=5-1=4

    //2.求最小值
    //总共有N个数，我们找到一个长度为N的连续序列，使上面尽可能有最多的石子，记为m
    //例如上面例子中，我们找到的序列为9~~13，长度为5，上面有3个石子
    //然后N-m即可，即我们把所有不在序列上的石子全部往序列上安放
    //有种特殊情况：1 2 3 4 _ _ 7
    //上面这种需要2步，因为边缘的空格>1，且中间的石子是已经连续的
    public int[] numMovesStonesII(int[] stones) {
        int[] res=new int[2];
        int len=stones.length;
        Arrays.sort(stones);
        if (stones[len-1]-stones[0]==len-1){
            res[0]=0;
            res[1]=0;
            return res;
        }
        int max=stones[len-1]-stones[0]+1-len-Math.min(stones[1]-stones[0]-1,stones[len-1]-stones[len-2]-1);
        res[1]=max;
        //记录连续序列里面的m
        int m=0,min=len;
        for (int i=0;i<len;i++){
            m=0;
            for (int j=i;j<len&&stones[j]<=stones[i]+len-1;j++){
                m++;
            }
            //还有种连续的特殊情况也需要排除 2 _ _ 5 6 7 8或者 1 2 3 4 _ _ 7
            if (m==len-1){
                if ((stones[len-1]-stones[1]+1==m&&stones[1]-stones[0]>2)||(stones[len-2]-stones[0]+1==m&&stones[len-1]-stones[len-2]>2)){
                    min=Math.min(2,min);
                }else{
                    min=1;
                }
            }else {
                min=Math.min(min,len-m);
            }
        }
        res[0]=min;
        return res;
    }
}
